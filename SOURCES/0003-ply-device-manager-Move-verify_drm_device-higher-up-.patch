From 7fbd59d04e971d327c3aaba417765f25c3168447 Mon Sep 17 00:00:00 2001
From: Hans de Goede <hdegoede@redhat.com>
Date: Wed, 28 Sep 2022 15:14:00 +0200
Subject: [PATCH 3/6] ply-device-manager: Move verify_drm_device() higher up in
 the file

Move verify_drm_device() higher up in ply-device-manager.c, this is
a preparation patch for the next patch in this series.

This is a pure move without any changes to the moved block.

Signed-off-by: Hans de Goede <hdegoede@redhat.com>
---
 src/libply-splash-core/ply-device-manager.c | 68 ++++++++++-----------
 1 file changed, 34 insertions(+), 34 deletions(-)

diff --git a/src/libply-splash-core/ply-device-manager.c b/src/libply-splash-core/ply-device-manager.c
index b2484b4..015bd70 100644
--- a/src/libply-splash-core/ply-device-manager.c
+++ b/src/libply-splash-core/ply-device-manager.c
@@ -236,60 +236,94 @@ fb_device_has_drm_device (ply_device_manager_t *manager,
         ply_trace ("trying to find associated drm node for fb device (path: %s)", id_path);
 
         udev_enumerate_scan_devices (card_matches);
 
         /* there should only ever be at most one match so we don't iterate through
          * the list, but just look at the first entry */
         card_entry = udev_enumerate_get_list_entry (card_matches);
 
         if (card_entry != NULL) {
                 struct udev_device *card_device = NULL;
                 const char *card_node;
                 const char *card_path;
 
                 card_path = udev_list_entry_get_name (card_entry);
                 card_device = udev_device_new_from_syspath (manager->udev_context, card_path);
                 card_node = udev_device_get_devnode (card_device);
                 if (card_node != NULL && drm_device_in_use (manager, card_node))
                         has_drm_device = true;
                 else
                         ply_trace ("no card node!");
 
                 udev_device_unref (card_device);
         } else {
                 ply_trace ("no card entry!");
         }
 
         udev_enumerate_unref (card_matches);
         return has_drm_device;
 }
 
+static bool
+verify_drm_device (struct udev_device *device)
+{
+        const char *id_path;
+
+        /*
+         * Simple-framebuffer devices driven by simpledrm lack information
+         * like panel-rotation info and physical size, causing the splash
+         * to briefly render on its side / without HiDPI scaling, switching
+         * to the correct rendering when the native driver loads.
+         * To avoid this treat simpledrm devices as fbdev devices and only
+         * use them after the timeout.
+         */
+        id_path = udev_device_get_property_value (device, "ID_PATH");
+        if (!ply_string_has_prefix (id_path, "platform-simple-framebuffer"))
+                return true; /* Not a SimpleDRM device */
+
+        /*
+         * With nomodeset, no native drivers will load, so SimpleDRM devices
+         * should be used immediately.
+         */
+        if (ply_kernel_command_line_has_argument ("nomodeset"))
+                return true;
+
+        /*
+         * Some firmwares leave the panel black at boot. Allow enabling SimpleDRM
+         * use from the cmdline to show something to the user ASAP.
+         */
+        if (ply_kernel_command_line_has_argument ("plymouth.use-simpledrm"))
+                return true;
+
+        return false;
+}
+
 static bool
 create_devices_for_udev_device (ply_device_manager_t *manager,
                                 struct udev_device   *device)
 {
         const char *device_path;
         bool created = false;
 
         device_path = udev_device_get_devnode (device);
 
         if (device_path != NULL) {
                 const char *subsystem;
                 ply_renderer_type_t renderer_type = PLY_RENDERER_TYPE_NONE;
 
                 subsystem = udev_device_get_subsystem (device);
                 ply_trace ("device subsystem is %s", subsystem);
 
                 if (subsystem != NULL && strcmp (subsystem, SUBSYSTEM_DRM) == 0) {
                         ply_trace ("found DRM device %s", device_path);
                         renderer_type = PLY_RENDERER_TYPE_DRM;
                 } else if (strcmp (subsystem, SUBSYSTEM_FRAME_BUFFER) == 0) {
                         ply_trace ("found frame buffer device %s", device_path);
                         if (!fb_device_has_drm_device (manager, device))
                                 renderer_type = PLY_RENDERER_TYPE_FRAME_BUFFER;
                         else
                                 ply_trace ("ignoring, since there's a DRM device associated with it");
                 }
 
                 if (renderer_type != PLY_RENDERER_TYPE_NONE) {
                         ply_terminal_t *terminal = NULL;
 
@@ -378,94 +412,60 @@ create_devices_for_subsystem (ply_device_manager_t *manager,
 static void
 on_drm_udev_add_or_change (ply_device_manager_t *manager,
                            const char           *action,
                            const char           *device_path,
                            struct udev_device   *device)
 {
         ply_renderer_t *renderer;
         bool changed;
 
         renderer = ply_hashtable_lookup (manager->renderers, (void *) device_path);
         if (renderer == NULL) {
                 /* We also try to create the renderer again on change events,
                  * renderer creation fails when no outputs are connected and
                  * this may have changed.
                  */
                 create_devices_for_udev_device (manager, device);
                 return;
         }
 
         /* Renderer exists, bail if this is not a change event */
         if (strcmp (action, "change"))
                 return;
 
         changed = ply_renderer_handle_change_event (renderer);
         if (changed) {
                 free_displays_for_renderer (manager, renderer);
                 create_pixel_displays_for_renderer (manager, renderer);
         }
 }
 
-static bool
-verify_drm_device (struct udev_device *device)
-{
-        const char *id_path;
-
-        /*
-         * Simple-framebuffer devices driven by simpledrm lack information
-         * like panel-rotation info and physical size, causing the splash
-         * to briefly render on its side / without HiDPI scaling, switching
-         * to the correct rendering when the native driver loads.
-         * To avoid this treat simpledrm devices as fbdev devices and only
-         * use them after the timeout.
-         */
-        id_path = udev_device_get_property_value (device, "ID_PATH");
-        if (!ply_string_has_prefix (id_path, "platform-simple-framebuffer"))
-                return true; /* Not a SimpleDRM device */
-
-        /*
-         * With nomodeset, no native drivers will load, so SimpleDRM devices
-         * should be used immediately.
-         */
-        if (ply_kernel_command_line_has_argument ("nomodeset"))
-                return true;
-
-        /*
-         * Some firmwares leave the panel black at boot. Allow enabling SimpleDRM
-         * use from the cmdline to show something to the user ASAP.
-         */
-        if (ply_kernel_command_line_has_argument ("plymouth.use-simpledrm"))
-                return true;
-
-        return false;
-}
-
 static bool
 verify_add_or_change (ply_device_manager_t *manager,
                       const char           *action,
                       const char           *device_path,
                       struct udev_device   *device)
 {
         const char *subsystem = udev_device_get_subsystem (device);
 
         if (strcmp (action, "add") && strcmp (action, "change"))
                 return false;
 
         subsystem = udev_device_get_subsystem (device);
 
         if (strcmp (subsystem, SUBSYSTEM_DRM) == 0) {
                 if (manager->local_console_managed && manager->local_console_is_text) {
                         ply_trace ("ignoring since we're already using text splash for local console");
                         return false;
                 }
 
                 if (!verify_drm_device (device)) {
                         ply_trace ("ignoring since we only handle SimpleDRM devices after timeout");
                         return false;
                 }
         } else {
                 ply_trace ("ignoring since we only handle subsystem %s devices after timeout", subsystem);
                 return false;
         }
 
         return true;
 }
-- 
2.37.0.rc1

