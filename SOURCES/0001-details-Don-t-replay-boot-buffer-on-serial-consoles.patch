From c42ff26b3dd3afa520946b1e28716055134cab50 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Tue, 30 Aug 2022 14:41:36 -0400
Subject: [PATCH] details: Don't replay boot buffer on serial consoles

commit 0e59dde8 changed the details plugin to clear the terminal when
first opening it. This was done to prevent duplicate messages from
showing up when toggling back and forth between details and graphical
splashes.

That has the negative side effect of purging serial console output too
though. Furthermore, it makes little sense to replay the boot buffer
on serial consoles, since serial consoles don't aggressively purge
scrollback like VTs do.

This commit adds a check to make sure the terminal is a VT before trying
to clear and replay the scrollback buffer.

Closes: https://gitlab.freedesktop.org/plymouth/plymouth/-/issues/187
---
 src/plugins/splash/details/plugin.c | 38 ++++++++++++++++++++---------
 1 file changed, 27 insertions(+), 11 deletions(-)

diff --git a/src/plugins/splash/details/plugin.c b/src/plugins/splash/details/plugin.c
index 254f682b..140fb282 100644
--- a/src/plugins/splash/details/plugin.c
+++ b/src/plugins/splash/details/plugin.c
@@ -175,109 +175,125 @@ destroy_plugin (ply_boot_splash_plugin_t *plugin)
                                                        detach_from_event_loop,
                                                        plugin);
                 detach_from_event_loop (plugin);
         }
 
         free_messages (plugin);
         free_views (plugin);
 
         free (plugin);
 }
 
 static void
 detach_from_event_loop (ply_boot_splash_plugin_t *plugin)
 {
         plugin->loop = NULL;
 
         ply_trace ("detaching from event loop");
 }
 
 static void
 view_write (view_t     *view,
             const char *text,
             size_t      number_of_bytes)
 {
         ply_terminal_t *terminal;
 
         terminal = ply_text_display_get_terminal (view->display);
         ply_terminal_write (terminal, "%.*s", (int) number_of_bytes, text);
 }
 
+static void
+view_write_boot_buffer (view_t *view)
+{
+        ply_boot_splash_plugin_t *plugin;
+        ply_terminal_t *terminal;
+
+        plugin = view->plugin;
+
+        terminal = ply_text_display_get_terminal (view->display);
+
+        ply_text_display_clear_screen (view->display);
+        ply_terminal_activate_vt (terminal);
+
+        if (plugin->boot_buffer != NULL) {
+                size_t size;
+                const char *bytes;
+
+                size = ply_buffer_get_size (plugin->boot_buffer);
+                bytes = ply_buffer_get_bytes (plugin->boot_buffer);
+                view_write (view, bytes, size);
+        }
+}
+
 static void
 write_on_views (ply_boot_splash_plugin_t *plugin,
                 const char               *text,
                 size_t                    number_of_bytes)
 {
         ply_list_node_t *node;
 
         if (number_of_bytes == 0)
                 return;
 
         node = ply_list_get_first_node (plugin->views);
 
         while (node != NULL) {
                 ply_list_node_t *next_node;
                 view_t *view;
 
                 view = ply_list_node_get_data (node);
                 next_node = ply_list_get_next_node (plugin->views, node);
 
                 view_write (view, text, number_of_bytes);
 
                 node = next_node;
         }
 }
 
 static void
 add_text_display (ply_boot_splash_plugin_t *plugin,
                   ply_text_display_t       *display)
 {
         view_t *view;
         ply_terminal_t *terminal;
 
         view = view_new (plugin, display);
 
         terminal = ply_text_display_get_terminal (view->display);
-        if (ply_terminal_open (terminal)) {
-                ply_text_display_clear_screen (view->display);        
-                ply_terminal_activate_vt (terminal);
-        }
 
-        ply_list_append_data (plugin->views, view);
+        ply_terminal_open (terminal);
 
-        if (plugin->boot_buffer != NULL) {
-                size_t size;
-                const char *bytes;
+        ply_list_append_data (plugin->views, view);
 
-                size = ply_buffer_get_size (plugin->boot_buffer);
-                bytes = ply_buffer_get_bytes (plugin->boot_buffer);
-                view_write (view, bytes, size);
+        if (ply_terminal_is_vt (terminal)) {
+                view_write_boot_buffer (view);
         }
 }
 
 static void
 remove_text_display (ply_boot_splash_plugin_t *plugin,
                      ply_text_display_t       *display)
 {
         ply_list_node_t *node;
 
         node = ply_list_get_first_node (plugin->views);
         while (node != NULL) {
                 view_t *view;
                 ply_list_node_t *next_node;
 
                 view = ply_list_node_get_data (node);
                 next_node = ply_list_get_next_node (plugin->views, node);
 
                 if (view->display == display) {
                         ply_list_remove_node (plugin->views, node);
                         return;
                 }
 
                 node = next_node;
         }
 }
 
 static bool
 show_splash_screen (ply_boot_splash_plugin_t *plugin,
                     ply_event_loop_t         *loop,
                     ply_buffer_t             *boot_buffer,
-- 
2.41.0.rc2

